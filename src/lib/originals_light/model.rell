
/**
 * The underlying token which can be either fungible or non-fungible.
 * Dapps are expected to create their own entities which references this token.
 * 
 * @param asset The FT4 asset that this token wraps.
 * @param collection The collection that this token belongs to.
 */
//matCzelusniak separate collection and token. It gives possibility to create token without collection. Uset ft4 asset directly without 'token' wrapper
// thanks to that we can have multiple collections for one token and not use collection in token
// entity token {
//   key asset: ft_assets.asset;
//   // collection;
// }

// matCzelusniak - use ft4 functionality instead of new entity
// entity token_balance {
//   key token, ft4.accounts.account;
//   mutable amount: integer;
// }

// todo matCzelusniak: Instead of refering strictly yo erc721 just use dynamic attributes. If user of lib want to use erc721 he can create it's own entity.
// sam comment is appropriate for all entities related to token below
// /**
//  * The image for a token. Compatible with ERC721 OpenSea standard.
//  * 
//  * @param token The token.
//  * @param url The URL of the image. This is mutable since the image can change.
//  */
// entity token_image {
//   key token;
//   mutable url: text;
// }

// /**
//  * The animation for a token. Compatible with ERC721 OpenSea standard.
//  * 
//  * @param token The token.
//  * @param url The URL of the animation. This is mutable since the animation can change.
//  */
// entity token_animation {
//   key token;
//   mutable url: text;
// }

/**
 * The description for a token. Compatible with ERC721 OpenSea standard.
 * 
 * @param token The token.
 * @param text The description. This is mutable since the description can change.
 */
// entity token_description {
//   key token;
//   mutable text;
// }

/**
 * Modules where tokens are allowed to operate within.
 * This is primarily used in order to prevent extendable functions with 
 * the wrong context from being executed.
 * 
 * @param token The token.
 * @param module_name The name of the module where the token has utility inside.
 */
entity asset_module {
  key asset: ft_assets.asset, module_name: name;
}

/**
 * Metadata that has arrived from a different blockchain.
 * Not every dapp will support the same modules (& utility) for a token.
 * 
 * While a chain `B`might only support the token to be used in module `X`.
 * In the above scenario `chain B` still need to persist metadata for module `B`,
 * since chain `B` has no idea about module `Y`. But if the tokens gets transferred 
 * to a chain `C` then we must not lose the metadata of module `Y`.
 * 
 * @param token The token that this attribute belongs to.
 * @param json The JSON representation of the attributes.
 */

// todo matCzelusniak: Just use dynamic attributes with type checking. If user of lib want to use json he can create it's own entity.
// entity imported_attributes {
//   key token;
//   mutable json;
// }

enum attribute_type {
  boolean,
  byte_array,
  decimal,
  instance,
  integer,
  text,
  big_integer
  // set,
  // list,
  //map
}

entity attribute {
  index asset: ft_assets.asset;
  index name: text;
  mutable value: byte_array;
  key asset, name;
  type: attribute_type;
}

//todo matCzelusniak: type for asset, but not obligatory
entity interface{
  key id: big_integer;
  index name: text;
}

entity interface_attributes {
  index interface: interface;
  attribute_name: text;
  type: attribute_type;
}

entity asset_interfaces {
  key asset: ft_assets.asset, interface: interface;
}