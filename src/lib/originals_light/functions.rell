function add_attribute_to_asset(
  asset_id: byte_array,
  attribute_name: text,
  type: attribute_type,
  attribute_value: byte_array
) {
  val asset = ft_assets.Asset(asset_id);

  before_add_attribute_to_asset(
    asset,
    attribute_name,
    type,
    attribute_value
  );

  when (type){
    attribute_type.boolean,
    attribute_type.byte_array,
    attribute_type.decimal,
    attribute_type.integer,
    attribute_type.text
     -> {
      create attribute(
        asset,
        name = attribute_name,
        value = attribute_value,
        type = type
      );
    }
    else -> {
      require(false, "Unsupported attribute type");
    }
  }

  after_add_attribute_to_asset(
    asset,
    attribute_name,
    type,
    attribute_value
  );
}

function register_asset(
  name,
  symbol: text,
  decimals: integer,
  blockchain_rid: byte_array,
  icon_url: text,
  type: text = ft_assets.ASSET_TYPE_FT4,
  attributes: list<(
    attribute_name: text,
    type: attribute_type,
    attribute_value: byte_array
  )>?
) : ft_assets.asset {
  before_register_asset(
    name,
    symbol,
    decimals,
    blockchain_rid,
    icon_url,
    type,
    attributes
  );

  val asset = ft_assets.Unsafe.register_asset(
    name = name,
    symbol = symbol,
    decimals = 0,
    blockchain_rid = chain_context.blockchain_rid,
    icon_url = icon_url,
    type = type
  );

  after_register_asset(
    asset,
    attributes
  );

  return asset;
}

function mint_asset(
  asset_id: byte_array,
  amount: big_integer,
  accounts: list<byte_array>?
) {
  before_mint(
    asset_id,
    amount,
    accounts
  );
  val accounts_list = get_accounts_to_mint(accounts);
  val asset = ft_assets.Asset(asset_id);

  for(account in accounts_list){
    ft_assets.Unsafe.mint(
      account,
      asset,
      amount
    );
  }

  after_mint(
    asset
  );
}

function register_interface(
  name: text,
  attributes: list<(
    attribute_name: text,
    type: attribute_type
  )>
) {
  interface @* {} ( @sort_desc .id ) limit 1;

  val last_id = (interface @* {} ( @sort_desc .id ) limit 1 );
  val next_id = if (last_id.size() > 0) last_id[0] + 1 else 1;

  val interface_created = create interface(
    id = next_id,
    name = name
  );

  for(attribute in attributes){
    create interface_attributes(
      interface = interface_created,
      attribute_name = attribute.attribute_name,
      type = attribute.type
    );
  }
}